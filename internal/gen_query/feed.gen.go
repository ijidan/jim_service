// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen_query

import (
	"context"
	"jim_service/internal/gen_model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newFeed(db *gorm.DB) feed {
	_feed := feed{}

	_feed.feedDo.UseDB(db)
	_feed.feedDo.UseModel(&gen_model.Feed{})

	tableName := _feed.feedDo.TableName()
	_feed.ALL = field.NewField(tableName, "*")
	_feed.ID = field.NewUint64(tableName, "id")
	_feed.UserID = field.NewUint64(tableName, "user_id")
	_feed.Content = field.NewString(tableName, "content")
	_feed.Type = field.NewInt32(tableName, "type")
	_feed.LikeCount = field.NewInt32(tableName, "like_count")
	_feed.ViewCount = field.NewInt32(tableName, "view_count")
	_feed.CommentCount = field.NewInt32(tableName, "comment_count")
	_feed.Operator = field.NewUint64(tableName, "operator")
	_feed.Remark = field.NewString(tableName, "remark")
	_feed.Hot = field.NewInt64(tableName, "hot")
	_feed.IsEnable = field.NewInt32(tableName, "is_enable")
	_feed.ReviewStatus = field.NewInt32(tableName, "review_status")
	_feed.CreatedAt = field.NewTime(tableName, "created_at")
	_feed.UpdatedAt = field.NewTime(tableName, "updated_at")
	_feed.DeletedAt = field.NewField(tableName, "deleted_at")
	_feed.FeedImage = feedHasManyFeedImage{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("FeedImage", "gen_model.FeedImage"),
	}

	_feed.FeedVideo = feedHasOneFeedVideo{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("FeedVideo", "gen_model.FeedVideo"),
	}

	_feed.FeedLike = feedHasManyFeedLike{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("FeedLike", "gen_model.FeedLike"),
	}

	_feed.fillFieldMap()

	return _feed
}

type feed struct {
	feedDo feedDo

	ALL          field.Field
	ID           field.Uint64
	UserID       field.Uint64
	Content      field.String
	Type         field.Int32
	LikeCount    field.Int32
	ViewCount    field.Int32
	CommentCount field.Int32
	Operator     field.Uint64
	Remark       field.String
	Hot          field.Int64
	IsEnable     field.Int32
	ReviewStatus field.Int32
	CreatedAt    field.Time
	UpdatedAt    field.Time
	DeletedAt    field.Field
	FeedImage    feedHasManyFeedImage

	FeedVideo feedHasOneFeedVideo

	FeedLike feedHasManyFeedLike

	fieldMap map[string]field.Expr
}

func (f feed) As(alias string) *feed {
	f.feedDo.DO = *(f.feedDo.As(alias).(*gen.DO))

	f.ALL = field.NewField(alias, "*")
	f.ID = field.NewUint64(alias, "id")
	f.UserID = field.NewUint64(alias, "user_id")
	f.Content = field.NewString(alias, "content")
	f.Type = field.NewInt32(alias, "type")
	f.LikeCount = field.NewInt32(alias, "like_count")
	f.ViewCount = field.NewInt32(alias, "view_count")
	f.CommentCount = field.NewInt32(alias, "comment_count")
	f.Operator = field.NewUint64(alias, "operator")
	f.Remark = field.NewString(alias, "remark")
	f.Hot = field.NewInt64(alias, "hot")
	f.IsEnable = field.NewInt32(alias, "is_enable")
	f.ReviewStatus = field.NewInt32(alias, "review_status")
	f.CreatedAt = field.NewTime(alias, "created_at")
	f.UpdatedAt = field.NewTime(alias, "updated_at")
	f.DeletedAt = field.NewField(alias, "deleted_at")

	f.fillFieldMap()

	return &f
}

func (f *feed) WithContext(ctx context.Context) *feedDo { return f.feedDo.WithContext(ctx) }

func (f feed) TableName() string { return f.feedDo.TableName() }

func (f *feed) GetFieldByName(fieldName string) (field.Expr, bool) {
	field, ok := f.fieldMap[fieldName]
	return field, ok
}

func (f *feed) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 18)
	f.fieldMap["id"] = f.ID
	f.fieldMap["user_id"] = f.UserID
	f.fieldMap["content"] = f.Content
	f.fieldMap["type"] = f.Type
	f.fieldMap["like_count"] = f.LikeCount
	f.fieldMap["view_count"] = f.ViewCount
	f.fieldMap["comment_count"] = f.CommentCount
	f.fieldMap["operator"] = f.Operator
	f.fieldMap["remark"] = f.Remark
	f.fieldMap["hot"] = f.Hot
	f.fieldMap["is_enable"] = f.IsEnable
	f.fieldMap["review_status"] = f.ReviewStatus
	f.fieldMap["created_at"] = f.CreatedAt
	f.fieldMap["updated_at"] = f.UpdatedAt
	f.fieldMap["deleted_at"] = f.DeletedAt

}

func (f feed) clone(db *gorm.DB) feed {
	f.feedDo.ReplaceDB(db)
	return f
}

type feedHasManyFeedImage struct {
	db *gorm.DB

	field.RelationField
}

func (a feedHasManyFeedImage) Where(conds ...field.Expr) *feedHasManyFeedImage {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a feedHasManyFeedImage) WithContext(ctx context.Context) *feedHasManyFeedImage {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a feedHasManyFeedImage) Model(m *gen_model.Feed) *feedHasManyFeedImageTx {
	return &feedHasManyFeedImageTx{a.db.Model(m).Association(a.Name())}
}

type feedHasManyFeedImageTx struct{ tx *gorm.Association }

func (a feedHasManyFeedImageTx) Find() (result []*gen_model.FeedImage, err error) {
	return result, a.tx.Find(&result)
}

func (a feedHasManyFeedImageTx) Append(values ...*gen_model.FeedImage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a feedHasManyFeedImageTx) Replace(values ...*gen_model.FeedImage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a feedHasManyFeedImageTx) Delete(values ...*gen_model.FeedImage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a feedHasManyFeedImageTx) Clear() error {
	return a.tx.Clear()
}

func (a feedHasManyFeedImageTx) Count() int64 {
	return a.tx.Count()
}

type feedHasOneFeedVideo struct {
	db *gorm.DB

	field.RelationField
}

func (a feedHasOneFeedVideo) Where(conds ...field.Expr) *feedHasOneFeedVideo {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a feedHasOneFeedVideo) WithContext(ctx context.Context) *feedHasOneFeedVideo {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a feedHasOneFeedVideo) Model(m *gen_model.Feed) *feedHasOneFeedVideoTx {
	return &feedHasOneFeedVideoTx{a.db.Model(m).Association(a.Name())}
}

type feedHasOneFeedVideoTx struct{ tx *gorm.Association }

func (a feedHasOneFeedVideoTx) Find() (result *gen_model.FeedVideo, err error) {
	return result, a.tx.Find(&result)
}

func (a feedHasOneFeedVideoTx) Append(values ...*gen_model.FeedVideo) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a feedHasOneFeedVideoTx) Replace(values ...*gen_model.FeedVideo) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a feedHasOneFeedVideoTx) Delete(values ...*gen_model.FeedVideo) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a feedHasOneFeedVideoTx) Clear() error {
	return a.tx.Clear()
}

func (a feedHasOneFeedVideoTx) Count() int64 {
	return a.tx.Count()
}

type feedHasManyFeedLike struct {
	db *gorm.DB

	field.RelationField
}

func (a feedHasManyFeedLike) Where(conds ...field.Expr) *feedHasManyFeedLike {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a feedHasManyFeedLike) WithContext(ctx context.Context) *feedHasManyFeedLike {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a feedHasManyFeedLike) Model(m *gen_model.Feed) *feedHasManyFeedLikeTx {
	return &feedHasManyFeedLikeTx{a.db.Model(m).Association(a.Name())}
}

type feedHasManyFeedLikeTx struct{ tx *gorm.Association }

func (a feedHasManyFeedLikeTx) Find() (result []*gen_model.FeedLike, err error) {
	return result, a.tx.Find(&result)
}

func (a feedHasManyFeedLikeTx) Append(values ...*gen_model.FeedLike) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a feedHasManyFeedLikeTx) Replace(values ...*gen_model.FeedLike) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a feedHasManyFeedLikeTx) Delete(values ...*gen_model.FeedLike) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a feedHasManyFeedLikeTx) Clear() error {
	return a.tx.Clear()
}

func (a feedHasManyFeedLikeTx) Count() int64 {
	return a.tx.Count()
}

type feedDo struct{ gen.DO }

func (f feedDo) Debug() *feedDo {
	return f.withDO(f.DO.Debug())
}

func (f feedDo) WithContext(ctx context.Context) *feedDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f feedDo) Clauses(conds ...clause.Expression) *feedDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f feedDo) Not(conds ...gen.Condition) *feedDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f feedDo) Or(conds ...gen.Condition) *feedDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f feedDo) Select(conds ...field.Expr) *feedDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f feedDo) Where(conds ...gen.Condition) *feedDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f feedDo) Order(conds ...field.Expr) *feedDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f feedDo) Distinct(cols ...field.Expr) *feedDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f feedDo) Omit(cols ...field.Expr) *feedDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f feedDo) Join(table schema.Tabler, on ...field.Expr) *feedDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f feedDo) LeftJoin(table schema.Tabler, on ...field.Expr) *feedDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f feedDo) RightJoin(table schema.Tabler, on ...field.Expr) *feedDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f feedDo) Group(cols ...field.Expr) *feedDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f feedDo) Having(conds ...gen.Condition) *feedDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f feedDo) Limit(limit int) *feedDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f feedDo) Offset(offset int) *feedDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f feedDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *feedDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f feedDo) Unscoped() *feedDo {
	return f.withDO(f.DO.Unscoped())
}

func (f feedDo) Create(values ...*gen_model.Feed) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f feedDo) CreateInBatches(values []*gen_model.Feed, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f feedDo) Save(values ...*gen_model.Feed) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f feedDo) First() (*gen_model.Feed, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*gen_model.Feed), nil
	}
}

func (f feedDo) Take() (*gen_model.Feed, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*gen_model.Feed), nil
	}
}

func (f feedDo) Last() (*gen_model.Feed, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*gen_model.Feed), nil
	}
}

func (f feedDo) Find() ([]*gen_model.Feed, error) {
	result, err := f.DO.Find()
	return result.([]*gen_model.Feed), err
}

func (f feedDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*gen_model.Feed, err error) {
	buf := make([]*gen_model.Feed, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f feedDo) FindInBatches(result *[]*gen_model.Feed, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f feedDo) Attrs(attrs ...field.AssignExpr) *feedDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f feedDo) Assign(attrs ...field.AssignExpr) *feedDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f feedDo) Joins(field field.RelationField) *feedDo {
	return f.withDO(f.DO.Joins(field))
}

func (f feedDo) Preload(field field.RelationField) *feedDo {
	return f.withDO(f.DO.Preload(field))
}

func (f feedDo) FirstOrInit() (*gen_model.Feed, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*gen_model.Feed), nil
	}
}

func (f feedDo) FirstOrCreate() (*gen_model.Feed, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*gen_model.Feed), nil
	}
}

func (f feedDo) FindByPage(offset int, limit int) (result []*gen_model.Feed, count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	result, err = f.Offset(offset).Limit(limit).Find()
	return
}

func (f feedDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f *feedDo) withDO(do gen.Dao) *feedDo {
	f.DO = *do.(*gen.DO)
	return f
}
